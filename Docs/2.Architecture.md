---
precedence: 2
version: 1.0.1
depends_on: [1.Project.md]
influences: [3.Structure.md,4.Entities.md,5.Pages.md,6.DesignSystem.md,7.Tasks.md]
last_update: 2025-12-20
---

# Projeto Bigtech — Arquitetura do Sistema

## Índice dos Documentos

- [1.Project.md](1.Project.md) - Visão geral do projeto
- [2.Architecture.md](2.Architecture.md) - Arquitetura técnica
- [3.Structure.md](3.Structure.md) - Estrutura do projeto
- [4.Entities.md](4.Entities.md) - Modelos de dados (entidades)
- [5.Pages.md](5.Pages.md) - Páginas e interfaces
- [6.UserStories.md](6.UserStories.md) - User Stories
- [7.Tasks.md](7.Tasks.md) - Tasks de implementação
- [8.DesignSystem.md](8.DesignSystem.md) - Design System

## 1. Descrição

O Projeto Bigtech é um SaaS multi-tenant orientado a plugins, com isolamento de tenants via containers Docker.
 
O CORE permanece mínimo e agnóstico, delegando funcionalidades variáveis a plugins.  
Cada tenant opera em container dedicado, consumindo dados de um backend Appwrite principal para funcionalidades compartilhadas (ex.: metadados de tenants, billing global).  

A arquitetura suporta:
- **Escalabilidade horizontal**  
- **Segurança baseada em isolamento**  
- **Extensibilidade via contratos de plugins**  

---

## 2. Princípio Arquitetural

- **CORE mínimo**: Núcleo central do sistema, responsável por autenticação, multi-tenancy, permissões, auditoria e Event Bus.  
- **Plugins**: Funcionalidades variáveis (consultas, pagamentos, mercado, relatórios).  
- **Isolamento multi-tenant**: Cada tenant roda em container Docker independente.  
- **Extensibilidade**: Novas integrações adicionadas como plugins sem alterar o CORE.  
- **Comunicação desacoplada**: Uso de Event Bus para notificações e orquestração de plugins.  
- **Integração com Appwrite**: Autenticação, storage e dados transversais, com isolamento lógico por tenant.

---

## 3. Camadas do Sistema

### 3.1 Frontends
- **Usuário (`frontend-user`)**: Consultas, histórico e compra de créditos. Tecnologia: Next.js (React).  
- **Admin (`frontend-admin`)**: Gestão de tenants, plugins e configurações. Tecnologia: Next.js (React).  
- **API Pública**: Opcional via plugin-atacado, autenticação via API Key (futuro, não no MVP).

### 3.2 Backend CORE
- **Responsabilidades**: Autenticação, multi-tenancy, plugin loader, Event Bus, billing genérico, auditoria e logs.  
- **Tecnologia**: Node.js/TypeScript, container Docker por tenant.  
- **Integração**: Consome APIs do Appwrite para dados compartilhados.

### 3.3 Plugins
- **Tipos**:
  - Consulta: Orquestram fontes de dados e normalizam respostas.  
  - Pagamento: Integração com gateways (Asaas, Pagarme).  
  - Mercado: Adaptação para varejo/atacado.  
  - Funcional: Recursos adicionais (relatórios, webhooks).  
- **Estrutura**: `plugins/tipo/fonte` (ex.: `plugins/consulta/infosimples`).  
- **Contratos**: Interfaces TypeScript padronizadas (`plugins/core/contracts.ts`).  
- **Execução**: Plugins carregados dinamicamente pelo CORE via plugin loader.

### 3.4 Backend Appwrite
- **Principal**: Dados compartilhados entre tenants (metadados, billing global).  
- **Isolamento por Tenant**: Containers conectam-se via API, mantendo bancos separados por tenant.  
- **Funcionalidades**: JWT, bancos (MariaDB/PostgreSQL), storage, funções serverless.

### 3.5 Containers Docker
- Cada tenant roda em container Docker dedicado com CORE + plugins ativos.  
- Orquestração via Docker Compose (MVP) ou Kubernetes (produção futura).

---

## 4. Fluxos Arquiteturais

### 4.1 Fluxo de Autenticação
1. Usuário acessa frontend.  
2. Requisição enviada ao CORE do tenant.  
3. CORE valida credenciais via Appwrite (JWT).  
4. Retorna interface apropriada ou erro.

### 4.2 Fluxo de Consulta
1. Usuário solicita consulta.  
2. Frontend chama API do CORE do tenant.  
3. CORE carrega plugin de consulta ativo.  
4. Plugin orquestra fontes de dados e normaliza resposta.  
5. CORE debita créditos, registra auditoria e retorna resultado.

### 4.3 Fluxo de Billing
1. Evento de consumo disparado via Event Bus.  
2. CORE processa billing genérico.  
3. Plugin de pagamento cria cobrança.  
4. Confirmação via webhook; dados armazenados no Appwrite.

### 4.4 Fluxo Multi-Tenant
- Cada tenant isolado em container Docker.  
- Containers conectam-se ao Appwrite principal com namespaces/databases separados.

---

## 5. Infraestrutura

### 5.1 Infraestrutura e Rede
- **Containers**: Docker para isolamento, Kubernetes para escalabilidade futura.  
- **Rede**: Isolamento via Docker/Kubernetes, balanceamento de carga via NGINX.  
- **Armazenamento**: Appwrite gerencia bancos e storage; backups automáticos.  
- **Monitoramento**: Logs centralizados, métricas via Prometheus/Grafana, alertas configuráveis.

### 5.2 Operações
- **Deploy**: CI/CD via GitHub Actions; containers buildados e deployados automaticamente.  
- **Escalabilidade**: Auto-scaling de containers, otimização de Appwrite para alta carga.  
- **Segurança**: TLS obrigatório, isolamento de containers, auditoria de logs.  
- **Backup e Recuperação**: Snapshots diários; disaster recovery via replicação.

---

## 6. Decisões Tecnológicas

- Frontend: Next.js (React), Shadecn, Tailwind CSS, Lucide Icons.
- Backend CORE/Plugins: Node.js/TypeScript.  
- BaaS: Appwrite.  
- Containers: Docker/Kubernetes.  
- Banco: MariaDB/PostgreSQL via Appwrite.  
- Comunicação: Event Bus (RabbitMQ).  
- Segurança: JWT, rate limiting, TLS, isolamento multi-tenant.

---

## 7. Contratos e Plugins

```typescript
interface Plugin {
  id: string;
  type: 'fonte' | 'consulta' | 'pagamento' | 'mercado' | 'funcional';
  version: string;
  install(): Promise<void>;
  enable(tenantId: string): Promise<void>;
  disable(tenantId: string): Promise<void>;
  execute(context: PluginContext): Promise<PluginResult>;
}
````

* **PluginContext**: Dados de entrada, tenant ID e configurações.
* **PluginResult**: Saída padronizada (dados normalizados, erros).
* Plugins se comunicam via Event Bus; não interagem diretamente.
* Plugin loader carrega/desabilita plugins dinamicamente por tenant.

---

## 8. Evolução Arquitetural

* **MVP**: CORE + plugins iniciais (Consultas por categoria: crédito, cadastral, veicular; Fonte de dados, Pagamento), frontends básicos, isolamento Docker.
* **Expansão**: Adição de plugins, API pública via plugin-atacado.
* **Escalabilidade**: Suporte a milhares de tenants, auto-scaling, otimização de Appwrite.
* **Segurança**: WAF, compliance LGPD, auditoria avançada.
* **Futuro**: Microserviços híbridos, integração com IA para normalização de dados.

---

## 9. Diagramas Arquiteturais (Texto)

### 9.1 Componentes Gerais

```
[Frontend Usuário] ----> [CORE (Container Tenant)]
[Frontend Admin ] ----> [CORE (Container Tenant)]
[API Pública     ] ----> [CORE (Container Tenant)]
[CORE] ----> [Plugins (Fonte, Consulta, Pagamento, etc.)]
[Plugins] ----> [Appwrite Principal]
[CORE] ----> [Event Bus] ----> [Plugins]
[Appwrite Principal] ----> [Banco MariaDB/PostgreSQL]
```

### 9.2 Fluxo de Consulta

```
Usuário -> Frontend -> CORE (Tenant Container) -> Plugin Consulta -> Plugin Fonte -> Fonte Externa
                                      |-> Event Bus -> Plugin Pagamento
                                      |-> Appwrite -> Armazenamento Logs/Billing
```

### 9.3 Isolamento Multi-Tenant

```
[Container Tenant 1] --isolated--> [Appwrite DB Tenant1]
[Container Tenant 2] --isolated--> [Appwrite DB Tenant2]
[Appwrite Principal] --shared--> [Metadados Globais, Billing Global]
```

---

## 10. Referências

* [Appwrite Documentation](https://appwrite.io/docs)
* [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
* [Kubernetes Multi-Tenancy](https://kubernetes.io/docs/concepts/security/multi-tenancy/)

---

## 11. Histórico de Versões

| Versão | Data       | Observação                                                                               |
| ------ | ---------- | ---------------------------------------------------------------------------------------- |
| 1.0.2  | 20/12/2025 | Refatoração para alinhar com categorias de consultas (crédito, cadastral, veicular) em MVP. |

```