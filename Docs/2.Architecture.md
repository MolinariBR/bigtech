# Projeto Bigtech — Arquitetura do Sistema

---
precedence: 2
version: 1.1.0
depends_on: [1.Project.md]
influences: [3.Structure.md,4.Entities.md,5.Pages.md,6.DesignSystem.md,7.Tasks.md]
last_update: 2025-12-20
---

## Índice dos Documentos

* [1.Project.md](1.Project.md) – Visão geral do projeto (**fonte de verdade imutável**)
* [2.Architecture.md](2.Architecture.md) – Arquitetura técnica
* [3.Structure.md](3.Structure.md) – Estrutura do projeto
* [4.Entities.md](4.Entities.md) – Modelos de dados (entidades)
* [5.Pages.md](5.Pages.md) – Páginas e interfaces
* [6.UserStories.md](6.UserStories.md) – User Stories
* [7.Tasks.md](7.Tasks.md) – Tasks de implementação
* [8.DesignSystem.md](8.DesignSystem.md) – Design System

## 1. Descrição

O Projeto Bigtech é um SaaS **multi-usuário com separação lógica por tenant**, orientado a plugins e executado em **infraestrutura compartilhada única**.

⚠️ **Decisão arquitetural obrigatória (derivada do 1.Project.md):**  
O sistema é **single-tenant em nível de infraestrutura**.  
Não existe isolamento por containers, instâncias, bancos ou ambientes por tenant.  
Todo isolamento ocorre **exclusivamente no nível de aplicação**, via autenticação, autorização, escopo de dados e configuração.

O CORE permanece mínimo e agnóstico, delegando funcionalidades variáveis a plugins carregados dinamicamente.  
Todos os tenants compartilham o mesmo backend, banco e serviços base, com segregação lógica garantida pelo modelo de dados e controle de acesso.

A arquitetura prioriza:
- **Simplicidade operacional**
- **Extensibilidade por plugins**
- **Governança e auditoria**
- **Baixo acoplamento entre funcionalidades**  

---

## 2. Princípios Arquiteturais

- **CORE mínimo**: Autenticação, autorização, tenants lógicos, plugin loader, auditoria, billing genérico e Event Bus.
- **Plugins**: Toda regra de negócio variável reside fora do CORE.
- **Tenancy lógico**: Isolamento por `tenantId` em dados, permissões e configurações.
- **Infraestrutura compartilhada**: Uma única aplicação, sem containers dedicados por tenant.
- **Extensibilidade controlada**: Plugins seguem contratos explícitos.
- **Comunicação desacoplada**: Event Bus para orquestração e efeitos colaterais.
- **Integração com Appwrite**: Autenticação, storage e persistência, com isolamento lógico.

---

## 3. Camadas do Sistema

### 3.1 Frontends
- **Usuário (`frontend-user`)**: Consultas, histórico e compra de créditos. Tecnologia: Next.js (React).  
- **Admin (`frontend-admin`)**: Gestão de tenants, plugins e configurações. Tecnologia: Next.js (React).  
- **API Pública**: Opcional via plugin-atacado, autenticação via API Key (futuro, não no MVP).

### 3.2 Backend CORE

- **Responsabilidades**:
  - Autenticação e autorização
  - Resolução de tenant lógico
  - Plugin loader
  - Event Bus
  - Billing genérico
  - Auditoria e logs

- **Tecnologia**: Node.js / TypeScript  
- **Execução**: Instância única compartilhada  
- **Integração**: Appwrite (BaaS)

❗ O CORE **nunca** replica instâncias por tenant.

### 3.3 Plugins
- **Tipos**:
  - Consulta: Orquestram fontes de dados e normalizam respostas.  
  - Pagamento: Integração com gateways (Asaas, Pagarme).  
  - Mercado: Adaptação para varejo/atacado.  
  - Funcional: Recursos adicionais (relatórios, webhooks).  
- **Estrutura**: `plugins/tipo/fonte` (ex.: `plugins/consulta/infosimples`).  
- **Contratos**: Interfaces TypeScript padronizadas (`plugins/core/contracts.ts`).  
- **Execução**:
  Plugins são carregados dinamicamente e executados **no contexto do tenant lógico**, sem isolamento físico.
- **Fonte Infosimples**: API externa para consultas de crédito, cadastral e veicular, integrada como fonte primária em plugins de consulta.

**Nota de Gestão de Plugins**: O sistema inclui um `pluginLoader` no CORE com as responsabilidades adicionais:
- Ativação/desativação dinâmica de plugins por `tenant`.
- Validação de dependências entre plugins (p.ex. plugin de pagamento requerido para operações de billing).
- Emissão de eventos no `Event Bus` para alterações de estado de plugins (install/enable/disable/configure/remove).
- Integração com o modulo de auditoria (`Audit`) para registrar todas as mudanças de plugins por tenant/usuário.
 - Validação de esquema de configuração (`PluginConfig`) no momento da configuração/instalação. O `pluginLoader` deve suportar validação baseada em JSON Schema (ou similar) e rejeitar configurações inválidas com mensagens de erro estruturadas.
 - Emissão de um `auditId` único para cada operação mutativa de plugin (install/enable/disable/configure/remove). Esse `auditId` deve ser retornado pela API do CORE e publicado via `Event Bus` para que UIs e sistemas externos possam referenciar logs completos.

### 3.4 Backend Appwrite

- **Uso**:
  - Autenticação (JWT)
  - Bancos de dados
  - Storage
  - Funções auxiliares

- **Isolamento**:
  - Lógico por `tenantId`
  - Sem bancos separados por tenant

### 3.5 Containers Docker

- Docker é utilizado **apenas como unidade de deploy da aplicação**, não como mecanismo de isolamento por tenant.
- Uma única stack Docker executa:
  - CORE
  - Plugins
  - Integrações

❌ Não existe container por tenant  
❌ Não existe rebuild ou restart por tenant

### 3.6 Auditoria e Logs
- **Responsabilidades do CORE**: Gerar logs automáticos para todas as ações administrativas e operacionais, incluindo consultas, alterações de plugins, transações de billing e mudanças de tenants. Logs são armazenados na entidade `Audit` com isolamento por tenant.
- **Geração Automática**: O módulo `audit.ts` no CORE registra ações com detalhes como tenantId, userId, action, resource, details, ipAddress e timestamp. Ações auditadas incluem: execução de consultas, ativação/desativação de plugins, compras de créditos, alterações em tenants e operações de billing.
- **Integração**: Logs são imutáveis, acessíveis via API para compliance, e exibidos na página `/audit` do frontend-admin com filtros e exportação.

---

## 4. Fluxos Arquiteturais

### 4.1 Fluxo de Autenticação
1. Usuário acessa frontend.  
2. Requisição enviada ao CORE do tenant.  
3. CORE valida credenciais via Appwrite (JWT).  
4. Retorna interface apropriada ou erro.

### 4.2 Fluxo de Consulta
1. Usuário solicita consulta.  
2. Frontend chama API do CORE do tenant.  
3. CORE carrega plugin de consulta ativo.  
4. Plugin orquestra fontes de dados e normaliza resposta.  
5. CORE debita créditos, registra auditoria e retorna resultado.

### 4.3 Fluxo de Billing
1. Evento de consumo disparado via Event Bus.  
2. CORE processa billing genérico.  
3. Plugin de pagamento cria cobrança.  
4. Confirmação via webhook; dados armazenados no Appwrite.

### 4.4 Isolamento Lógico

- Todos os tenants compartilham a mesma infraestrutura
- Isolamento via `tenantId` em dados, permissões e configurações
- Sem containers, bancos ou instâncias separados

---

## 5. Infraestrutura

### 5.1 Infraestrutura

- **Execução**: Docker
- **Rede**: NGINX
- **Banco**: Appwrite (PostgreSQL/MariaDB)
- **Monitoramento**: Logs + métricas

### 5.2 Segurança

- JWT
- Rate limiting
- TLS
- Auditoria obrigatória
- Nenhum isolamento físico por tenant

### 5.3 Monitoramento de Billing e Observabilidade
- O sistema deve expor endpoints de agregação e relatórios para monitoramento de billing (por tenant, por período, por plugin). Esses endpoints são utilizados pelo `frontend-admin` para gerar relatórios, gráficos e exportações (CSV/PDF).
- Eventos de consumo e transações devem publicar mensagens no `Event Bus` para processamento assíncrono pelo `billingEngine` e para geração de alertas e métricas (Prometheus/Grafana).
- Operações que alteram saldo ou processam reembolsos devem gerar entradas em `Audit` com `auditId` retornado pelo CORE e referenciado na UI.
- Alertas e regras de detecção (ex.: picos de consumo, cobranças duplicadas, falhas de pagamentos) devem ser configuráveis e emitidas para canais de monitoramento/ops.

---

## 6. Decisões Tecnológicas

- Frontend: Next.js, Shadcn, Tailwind
- Backend: Node.js / TypeScript
- BaaS: Appwrite
- Mensageria: RabbitMQ
- Containers: Docker (deploy, não tenancy)

---

## 7. Contratos de Plugins

```ts
interface Plugin {
  id: string;
  type: 'fonte' | 'consulta' | 'pagamento' | 'mercado' | 'funcional';
  version: string;
  install(): Promise<void>;
  enable(tenantId: string): Promise<void>;
  disable(tenantId: string): Promise<void>;
  execute(context: PluginContext): Promise<PluginResult>;
}
```

---

## 8. Evolução Arquitetural

* **MVP**: CORE + plugins iniciais
* **Expansão**: Novos plugins
* **Escala**: Horizontal por carga, não por tenant
* **Futuro**: Extração seletiva de serviços se necessário

---

## 8. Diagramas (Texto)

### 8.1 Geral

```
[Frontend User ] --> [CORE]
[Frontend Admin] --> [CORE]
[CORE] --> [Plugins]
[Plugins] --> [Appwrite]
[CORE] --> [Event Bus]
```

### 8.2 Isolamento Lógico

```
Tenant A --+
Tenant B --+--> [CORE + Plugins] --> [DB compartilhado]
Tenant C --+
```

---

## 9. Histórico de Versões

| Versão | Data       | Observação                                                       |
| ------ | ---------- | ---------------------------------------------------------------- |
| 1.1.0  | 20/12/2025 | Alinhamento completo com tenancy lógico definido em 1.Project.md |

---

### Resultado final

Agora:
- ✅ **Architecture NÃO contradiz Project**
- ✅ **IA não criará containers por tenant**
- ✅ **Structure / Entities / Tasks ficam protegidos**
- ✅ **Você pode evoluir sem dívida conceitual**
