# Projeto Bigtech — Arquitetura do Sistema

---
precedence: 2
version: 1.2.0
depends_on: [1.Project.md]
influences: [3.Structure.md,4.Entities.md,5.Pages.md,6.DesignSystem.md,7.Tasks.md]
last_update: 2025-12-27
---

## Índice dos Documentos

* [1.Project.md](1.Project.md) – Visão geral do projeto (**fonte de verdade imutável**)
* [2.Architecture.md](2.Architecture.md) – Arquitetura técnica
* [3.Structure.md](3.Structure.md) – Estrutura do projeto
* [4.Entities.md](4.Entities.md) – Modelos de dados (entidades)
* [5.Pages.md](5.Pages.md) – Páginas e interfaces
* [6.UserStories.md](6.UserStories.md) – User Stories
* [7.Tasks.md](7.Tasks.md) – Tasks de implementação
* [8.DesignSystem.md](8.DesignSystem.md) – Design System

## 1. Descrição

O Projeto Bigtech é um SaaS **multi-usuário com classificação direta de usuários**, orientado a plugins e executado em **infraestrutura compartilhada única**.

⚠️ **Decisão arquitetural obrigatória (derivada do 1.Project.md):**  
O sistema é **single-tenant em nível de infraestrutura**.  
Não existe isolamento por containers, instâncias, bancos ou ambientes.  
Todo isolamento ocorre **exclusivamente no nível de aplicação**, via autenticação, autorização, tipo de usuário e permissões.

O CORE permanece mínimo e agnóstico, delegando funcionalidades variáveis a plugins carregados dinamicamente.  
Todos os usuários compartilham o mesmo backend, banco e serviços base, com segregação lógica garantida pelo modelo de dados e controle de acesso baseado no tipo de usuário ('empresa' ou 'usuario_final').

A arquitetura prioriza:
- **Simplicidade operacional**
- **Extensibilidade por plugins**
- **Governança e auditoria**
- **Baixo acoplamento entre funcionalidades**  

---

## 2. Princípios Arquiteturais

- **CORE mínimo**: Autenticação, autorização, classificação de usuários, plugin loader, auditoria, billing genérico e Event Bus.
- **Plugins**: Toda regra de negócio variável reside fora do CORE.
- **Classificação de usuários**: Usuários são classificados como 'empresa' ou 'usuario_final' com permissões baseadas no tipo.
- **Infraestrutura compartilhada**: Uma única aplicação, sem containers dedicados.
- **Extensibilidade controlada**: Plugins seguem contratos explícitos.
- **Comunicação desacoplada**: Event Bus para orquestração e efeitos colaterais.
- **Integração com Appwrite**: Autenticação, storage e persistência, com isolamento baseado em tipo de usuário.

---

## 3. Camadas do Sistema

### 3.1 Frontends
- **Usuário (`frontend-user`)**: Consultas, histórico e compra de créditos. Tecnologia: Next.js (React).  
- **Admin (`frontend-admin`)**: Gestão de tenants, plugins e configurações. Tecnologia: Next.js (React).  
- **API Pública**: Opcional via plugin-atacado, autenticação via API Key (futuro, não no MVP).

### 3.2 Backend CORE

- **Responsabilidades**:
  - Autenticação e autorização
  - Classificação de usuários ('empresa' ou 'usuario_final')
  - Plugin loader
  - Event Bus
  - Billing genérico
  - Auditoria e logs

- **Tecnologia**: Node.js / TypeScript  
- **Execução**: Instância única compartilhada  
- **Integração**: Appwrite (BaaS)

❗ O CORE **nunca** replica instâncias por tipo de usuário.

### 3.3 Plugins
- **Tipos**:
  - Consulta: Orquestram fontes de dados e normalizam respostas.  
  - Pagamento: Integração com gateways (Asaas, Pagarme).  
  - Mercado: Adaptação para varejo/atacado.  
  - Funcional: Recursos adicionais (relatórios, webhooks).  
- **Estrutura**: `plugins/tipo/fonte` (ex.: `plugins/consulta/infosimples`).  
- **Contratos**: Interfaces TypeScript padronizadas (`plugins/core/contracts.ts`).  
- **Execução**:
  Plugins são carregados dinamicamente e executados **no contexto do tenant lógico**, sem isolamento físico.
- **Fonte Infosimples**: API externa para consultas de crédito, cadastral e veicular, integrada como fonte primária em plugins de consulta.

**Nota de Gestão de Plugins**: O sistema inclui um `pluginLoader` no CORE com as responsabilidades adicionais:
- Ativação/desativação dinâmica de plugins globalmente ou por tipo de usuário.
- Validação de dependências entre plugins (p.ex. plugin de pagamento requerido para operações de billing).
- Emissão de eventos no `Event Bus` para alterações de estado de plugins (install/enable/disable/configure/remove).
- Integração com o modulo de auditoria (`Audit`) para registrar todas as mudanças de plugins por usuário.
 - Validação de esquema de configuração (`PluginConfig`) no momento da configuração/instalação. O `pluginLoader` deve suportar validação baseada em JSON Schema (ou similar) e rejeitar configurações inválidas com mensagens de erro estruturadas.
 - Emissão de um `auditId` único para cada operação mutativa de plugin (install/enable/disable/configure/remove). Esse `auditId` deve ser retornado pela API do CORE e publicado via `Event Bus` para que UIs e sistemas externos possam referenciar logs completos.

### 3.4 Backend Appwrite

- **Uso**:
  - Autenticação (JWT)
  - Bancos de dados
  - Storage
  - Funções auxiliares

- **Isolamento**:
  - Baseado no tipo de usuário ('empresa' ou 'usuario_final')
  - Sem bancos separados

### 3.5 Containers Docker

- Docker é utilizado **apenas como unidade de deploy da aplicação**, não como mecanismo de isolamento.
- Uma única stack Docker executa:
  - CORE
  - Plugins
  - Integrações

❌ Não existe container por tipo de usuário  
❌ Não existe rebuild ou restart por tipo de usuário

### 3.6 Auditoria e Logs
- **Responsabilidades do CORE**: Gerar logs automáticos para todas as ações administrativas e operacionais, incluindo consultas, alterações de plugins, transações de billing e mudanças de usuários. Logs são armazenados na entidade `Audit` com isolamento por tipo de usuário.
- **Geração Automática**: O módulo `audit.ts` no CORE registra ações com detalhes como userId, action, resource, details, ipAddress e timestamp. Ações auditadas incluem: execução de consultas, ativação/desativação de plugins, compras de créditos, alterações em usuários e operações de billing.
- **Integração**: Logs são imutáveis, acessíveis via API para compliance, e exibidos na página `/audit` do frontend-admin com filtros e exportação.

---

## 4. Fluxos Arquiteturais

### 4.1 Fluxo de Autenticação
1. Usuário acessa frontend.  
2. Requisição enviada ao CORE.  
3. CORE valida credenciais via Appwrite (JWT) e determina tipo de usuário.  
4. Retorna interface apropriada baseada no tipo ('empresa' ou 'usuario_final') ou erro.

### 4.2 Fluxo de Consulta
1. Usuário solicita consulta.  
2. Frontend chama API do CORE.  
3. CORE carrega plugin de consulta disponível baseado no tipo de usuário.  
4. Plugin orquestra fontes de dados e normaliza resposta.  
5. CORE debita créditos, registra auditoria e retorna resultado.

### 4.3 Fluxo de Billing
1. Evento de consumo disparado via Event Bus.  
2. CORE processa billing genérico baseado no tipo de usuário.  
3. Plugin de pagamento cria cobrança.  
4. Confirmação via webhook; dados armazenados no Appwrite.

### 4.4 Isolamento Lógico

- Todos os usuários compartilham a mesma infraestrutura
- Isolamento via tipo de usuário ('empresa' ou 'usuario_final') em dados, permissões e configurações
- Sem containers, bancos ou instâncias separados

---

## 5. Infraestrutura

### 5.1 Infraestrutura

- **Execução**: Docker
- **Rede**: NGINX
- **Banco**: Appwrite (PostgreSQL/MariaDB)
- **Monitoramento**: Logs + métricas

### 5.2 Segurança

- JWT
- Rate limiting
- TLS
- Auditoria obrigatória
- Nenhum isolamento físico por tenant

### 5.3 Monitoramento de Billing e Observabilidade
- O sistema deve expor endpoints de agregação e relatórios para monitoramento de billing (por tipo de usuário, por período, por plugin). Esses endpoints são utilizados pelo `frontend-admin` para gerar relatórios, gráficos e exportações (CSV/PDF).
- Eventos de consumo e transações devem publicar mensagens no `Event Bus` para processamento assíncrono pelo `billingEngine` e para geração de alertas e métricas (Prometheus/Grafana).
- Operações que alteram saldo ou processam reembolsos devem gerar entradas em `Audit` com `auditId` retornado pelo CORE e referenciado na UI.
- Alertas e regras de detecção (ex.: picos de consumo, cobranças duplicadas, falhas de pagamentos) devem ser configuráveis e emitidas para canais de monitoramento/ops.

---

## 6. Decisões Tecnológicas

- Frontend: Next.js, Shadcn, Tailwind
- Backend: Node.js / TypeScript
- BaaS: Appwrite
- Mensageria: RabbitMQ
- Containers: Docker (deploy, não isolamento por tipo de usuário)

---

## 7. Contratos de Plugins

```ts
interface Plugin {
  id: string;
  type: 'fonte' | 'consulta' | 'pagamento' | 'mercado' | 'funcional';
  version: string;
  install(): Promise<void>;
  enable(userType: 'empresa' | 'usuario_final'): Promise<void>;
  disable(userType: 'empresa' | 'usuario_final'): Promise<void>;
  execute(context: PluginContext): Promise<PluginResult>;
}
```

---

## 8. Evolução Arquitetural

* **MVP**: CORE + plugins iniciais
* **Expansão**: Novos plugins
* **Escala**: Horizontal por carga, não por tipo de usuário
* **Futuro**: Extração seletiva de serviços se necessário

---

## 8. Diagramas (Texto)

### 8.1 Geral

```
[Frontend User ] --> [CORE]
[Frontend Admin] --> [CORE]
[CORE] --> [Plugins]
[Plugins] --> [Appwrite]
[CORE] --> [Event Bus]
```

### 8.2 Isolamento Lógico

```
Empresa --+
Usuário Final --+--> [CORE + Plugins] --> [DB compartilhado]
```

---

## 9. Histórico de Versões

| Versão | Data       | Observação                                                       |
| ------ | ---------- | ---------------------------------------------------------------- |
| 1.2.0  | 27/12/2025 | Remoção do conceito de tenant; isolamento baseado em tipo de usuário ('empresa' ou 'usuario_final') |
| 1.1.0  | 20/12/2025 | Alinhamento completo com tenancy lógico definido em 1.Project.md |

---

### Resultado final

Agora:
- ✅ **Architecture NÃO contradiz Project**
- ✅ **IA não criará containers por tenant**
- ✅ **Structure / Entities / Tasks ficam protegidos**
- ✅ **Você pode evoluir sem dívida conceitual**
